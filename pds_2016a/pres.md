---
vim: spell spelllang=en fo+=t tw=80
title: Stateless Model Checking for POWER \cite{POWER}
author:
    - Parosh Aziz Abdulla
    - Mohamed Faouzi Atig
    - Bengt Jonsson
    - Carl Leonardsson
    - \
    - presented by Vladimír Štill
lang: english
date: 31th October 2016
...

## Stateless Model Checking

*   old idea (1997, \cite{godefroid1997model})
*   states of real-world systems can be large and hard to store
    *   solution is to not store them
*   similar to explicit-state MC but has no closed set
*   uses partial order reduction try to avoid exploring states many times
*   bounded number of cycle unrollings

## POWER Architecture

*   the paper focused on verification under the POWER relaxed memory model
*   very weak memory model
*   reordering of stores, loads

\includegraphics[page=4, clip, trim=5.4cm 16.5cm 5.1cm 9cm, width=\textwidth]{paper}

*   for example, in the program above, we can end with $y = 2$ **and** $r_1 = 2$
    *   if `L2` and `L3` are reordered

## POWER Memory Model

\includegraphics[page=4, clip, trim=5.4cm 17.3cm 5.1cm 9cm, width=\textwidth]{paper}

*   several relations between statements of the program used in the definition
    *   `po` -- *program order* ($(s, s') \in \mathtt{po}$ iff statement $s'$ is
        executed by the same thread after $s$ is executed)
    *   `rf` -- *read from* ($(s, l) \in \mathtt{rf})$ iff $s$ is `store`, $l$ is
        `load` and $l$ reads value written by $s$)
    *   `co` -- *coherence order* ($(s, s') \in \mathtt{co}$ iff stores $s$ and
        $s'$ share memory location and $s$ is executed before $s'$)
*   memory model defined in terms of *commit before order* (`cb`)
    *   partial order
    *   *"action can be committed if all actions it depends on were committed"*
    *   complex, no need to know details

## Axiomatic and Executable Memory Model

*   POWER memory model given as an axiomatic model \cite{alglave2014herding}
*   paper presents a way to efficiently derive executable model
    *   basically, for each possible instruction execution, check if it
        satisfies axiomatic model

*   different executions described by *Shasha-Snir traces*
    *   *trace* = set $E$ of events (instructions) + `po`, `co`, `rf` relations
        over $E$
    *   a trace corresponds to multiple linearizations of the program which
        yield same results

\pause

*   deriving valid traces
    *   derive *commit before order* from the axiomatic mode (probably manually)
    *   valid traces are generated by successively adding events and checking
        that `cb` on given trace is acyclic
    *   `cb` has to be such that it not only allows exactly behaviours of the
        memory model, but also stops invalid executions as soon as possible

## Load and Store Semantics I

*   in the modelled language, only `load` and `store` instructions access memory
    (similarly to LLVM)
*   `load` can load from any store to the same memory location executed before
*   `store` can be inserted anywhere in the coherence order of given memory
    location
    *   `store` encountered later by the exploration algorithm can behave as if
        it was executed earlier

## Load and Store Semantics II

*   when exploring, loads and stores have nondeterministic parameters
    *   `load` is parametrized by the `store` it reads from (selected from the
        already executed stores)
    *   `store` is parametrized by its position in the coherence order of
        executed stores over given memory location
*   run fully determined by the sequence of loads and stores with their
    parameters (thread are deterministic)
*   misses the possibility of `load` fetching value of a `store` which will be
    encountered later
    *   fixed on the level of the exploration algorithm

\begin{latex}
\includegraphics[page=4, clip, trim=5.4cm 17.3cm 11.7cm 9cm, scale=0.95]{paper}%
\includegraphics[page=10, clip, trim=7.5cm 18.2cm 7.1cm 7.8cm, scale=0.95]{paper}
\end{latex}

## Relaxed Stateless Model Checking Algorithm I

*   keeps set of committed instructions, fetched instructions, numerous orders
    between instructions (= state) + run of the program
*   starts at initial state
*   in each state:
    #.  execute as many local instructions as possible (i.e. not loads and
        stores)
    #.  consider (`load` or `store`) instructions $e$ whose `cb`-predecessors
        have already been committed, extend the state by any allowed
        parametrization of $e$ and continue recursively from this state
    #.  if any read-write conflicts (races) were detected during the
        exploration, allow their reversal

. . .

*   race is an occurrence of `load` $l$ followed by `store` $s$ to the same
    location, such that $l$ is not `cb`-ordered before $s$ and therefore their
    order can be reversed and, in such a case, $l$ can read value stored by $s$

## Relaxed Stateless Model Checking Algorithm II

\begin{latex}
\begin{minipage}{0.45\textwidth}
\includegraphics[page=12, clip, trim=5.5cm 17.5cm 11cm 4.4cm]{paper}
\end{minipage}\hfill\begin{minipage}{0.45\textwidth}
race between \texttt{load} $e_r[e_w]$ and \texttt{store} $\widehat{e}_w[p]$
causes new run starting with $\tau_2$ to be explored from the place of execution
of $e_r$
\end{minipage}
\end{latex}


## Relaxed Stateless Model Checking Algorithm III

\begin{latex}
\begin{minipage}{0.4\textwidth}
\includegraphics[page=12, clip, trim=11.5cm 16cm 5.8cm 4.4cm]{paper}
\end{minipage}\hfill\begin{minipage}{0.53\textwidth}
race between \texttt{load} $e_r[\widehat{e}_w]$ and \texttt{store}
$\widehat{\widehat{e}}_w[p']$ causes new run starting with $\tau_4$ to be
explored

\begin{itemize}
\item from the point in which $e_r$ was first discovered.
\item to avoid unnecessary re-discovery of the same trace
\end{itemize}
\end{minipage}
\end{latex}

## Implementation

*   implemented in Nidhugg
*   "a bug-finding tool which targets bugs caused by concurrency
    and relaxed memory consistency in concurrent programs. It works on the
    level of LLVM internal representation, which means that it can be used
    for programs written in languages such as C or C++."

*   "Nidhugg supports the SC, TSO, PSO, POWER and ARM memory models. Target
    programs should use pthreads for concurrency, and each thread should be
    deterministic when run in isolation."
*   <https://github.com/nidhugg/nidhugg>

## Results

\centering\includegraphics[page=16, clip, trim=4.6cm 11.5cm 4.8cm 4.65cm, height=\textheight]{paper}

## Bibliography {.allowframebreaks}

\bibliographystyle{plain}
\bibliography{pres}

