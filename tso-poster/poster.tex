%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jacobs Portrait Poster
% LaTeX Template
% Version 1.0 (31/08/2015)
% (Based on Version 1.0 (29/03/13) of the landscape template
%
% Created by:
% Computational Physics and Biophysics Group, Jacobs University
% https://teamwork.jacobs-university.de:8443/confluence/display/CoPandBiG/LaTeX+Poster
% 
% Further modified by:
% Nathaniel Johnston (nathaniel@njohnston.ca)
%
% Portrait version by:
% John Hammersley
%
% The landscape version of this template was downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[final, 20pt, a0]{beamer}


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage[scale=1.15]{beamerposter} % Use the beamerposter package for laying out the poster

\usetheme{confposter} % Use the confposter theme supplied with this template

\usepackage{natbib}

\definecolor{mublue}{RGB}{27,69,143} % {cmyk}{0.81,0.52,0,0.44}
\setbeamercolor{structure}{fg=mublue}
\setbeamercolor{cboxb}{bg=mublue}
\setbeamercolor{title in headline}{fg=mublue}
\setbeamercolor{block title}{fg=mublue,bg=white} % Colors of the block titles
\setbeamercolor{block body}{fg=black,bg=white} % Colors of the body of blocks
\setbeamercolor{block alerted title}{fg=white,bg=mublue} % Colors of the highlighted block titles
\setbeamercolor{block alerted body}{fg=black,bg=mublue} % Colors of the body of highlighted blocks
% Many more colors are available for use in beamerthemeconfposter.sty

%-----------------------------------------------------------
% Define the column widths and overall poster size
% To set effective sepwid, onecolwid and twocolwid values, first choose how many columns you want and how much separation you want between columns
% In this template, the separation width chosen is 0.024 of the paper width and a 4-column layout
% onecolwid should therefore be (1-(# of columns+1)*sepwid)/# of columns e.g. (1-(4+1)*0.024)/4 = 0.22
% Set twocolwid to be (2*onecolwid)+sepwid = 0.464
% Set threecolwid to be (3*onecolwid)+2*sepwid = 0.708

\newlength{\sepwid}
\newlength{\marginwid}
\newlength{\onecolwid}
\newlength{\twocolwid}
\newlength{\threecolwid}
% \setlength{\paperwidth}{841mm} % A0 width: 46.8in
% \setlength{\paperheight}{1189mm} % A0 height: 33.1in
\setlength{\sepwid}{20mm} % Separation width (white space) between columns
\setlength{\marginwid}{80mm} % Margin width (white space) left and right
\setlength{\onecolwid}{214mm} % Width of one column
\setlength{\twocolwid}{\onecolwid} % Width of two columns
\addtolength{\twocolwid}{\onecolwid}
\addtolength{\twocolwid}{\sepwid}
\setlength{\threecolwid}{0.708\paperwidth} % Width of three columns
\setlength{\topmargin}{1cm}

\usepackage{xspace}
\usepackage{pdfpages}
\usepackage{microtype}

\newcommand{\TODO}[1]{\textcolor{red}{#1}}

%-----------------------------------------------------------
\usepackage{wrapfig}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,arrows.meta,decorations.markings}

\usepackage{graphicx}  % Required for including images
\usepackage{booktabs} % Top and bottom rules for tables
\usepackage[english]{babel}

\usepackage{lipsum}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\titletext}{Verification of C and C++ under the~x86-TSO Memory Model}
\newcommand{\logowidth}{2.6\baselineskip}
\title{%
  \texorpdfstring{%
    \makebox[\linewidth]{%
      \noindent\hspace*{0.5em} %
      \begin{minipage}{\logowidth}%
          \includegraphics[width=\logowidth]{mu_logo.pdf} %
      \end{minipage}%
      \hfill %
      \begin{minipage}{\linewidth - \logowidth - \logowidth - 3em}\center\titletext\end{minipage} %
      \hfill %
      \begin{minipage}{\logowidth}%
         \includegraphics[width=\logowidth]{fi_logo.pdf} %
      \end{minipage}
      \hspace*{0.5em}%
    }%
  }
  {\titletext}} % Poster title

\author{Vladimír Štill \and Jiří Barnat} % Author(s)

\institute{Faculty of Informatics, Masaryk University\vspace*{-3cm}} % Institution(s)

%----------------------------------------------------------------------------------------

\newcommand{\xtso}{x86-TSO\xspace}
\newcommand{\divine}{\mbox{DIVINE}\xspace}

\begin{document}

\addtobeamertemplate{block end}{}{\vspace*{2ex}} % White space under blocks
\addtobeamertemplate{block alerted end}{}{\vspace*{2ex}} % White space under highlighted (alert) blocks

\setlength{\belowcaptionskip}{2ex} % White space under figures
\setlength\belowdisplayshortskip{2ex} % White space under equations

\begin{frame}[t] % The whole poster is enclosed in one beamer frame

\begin{columns}[t] % The whole poster consists of three major columns, the second of which is split into two columns twice - the [t] option aligns each column's content to the top

\begin{column}{\marginwid}\end{column} % Empty spacer column
\begin{column}{\onecolwid} % The first column

\begin{block}{Relaxed Memory}

Almost all server, desktop, and laptop processors manufactured in later decades
exhibit relaxed memory behaviour, which together with the rise of multicore
processors and parallel programs means that programmers have to deal with its
additional complexities. Even on x86 processors, which have stronger memory
model than most other architectures, programmers often have to decide whether
to play safe with higher level synchronization constructs such as mutexes, or
tap to the full power of the architecture and risk subtle unintuitive behaviour
of relaxed memory accesses.

Here, we present an extension of the \divine verifier~\cite{DIVINEToolPaper2017}
which allows analysis of C and C++ programs under the \xtso memory model of
current Intel/AMD CPUs~\cite{x86tso}.  We show that by carefully designing the
relaxed semantics it is possible to integrate it into explicit-state model
checking in a way which is competitive to both bounded model checking and
stateless model checking, while at the same time being more general and
extensible.

\end{block}

\end{column} % End of the first column

\begin{column}{\sepwid}\end{column} % Empty spacer column

\begin{column}{\twocolwid} % Begin a column which is two columns wide (column 2)

\begin{block}{The \xtso Memory Model}

    \begingroup
    \centering
    \tt
    \begin{columns}
    \begin{column}{12cm}
    \textcolor{dgreen}{int} x = 0, y = 0; \\
    \textcolor{dgreen}{void} thread0() \{ \\
    \ \ \ \ y = 1; \\
    \ \ \ \ \textcolor{dgreen}{int} a = x; \\
    \ \ \ \ \textcolor{dgreen}{int} c = y; \\
    \}
    \end{column}
    \begin{column}{12cm}
    \mbox{}\\
    \textcolor{dgreen}{void} thread0() \{ \\
    \ \ \ \ y = 1; \\
    \ \ \ \ \textcolor{dgreen}{int} b = x; \\
    \ \ \ \ \textcolor{dgreen}{int} d = y; \\
    \}
    \end{column}
    \end{columns}\mbox{}

    \noindent\medskip
    reachable? a == 0 \&\& b == 0\\[2ex]
    \endgroup

    \begin{center}
    \begin{tikzpicture}[ ->, >=stealth', shorten >=1pt, auto, node distance=3cm
                       , semithick
                       , scale=2
                       , thck/.style = { thick, decoration={markings,mark=at position 1 with {\arrow[scale=4]{>}}}, postaction={decorate}, },
                       ]

      \draw [-] (-10,0) rectangle (-7,-5);
      \draw [-] (-10,-1) -- (-7,-1)
                (-10,-2) -- (-7,-2)
                (-10,-3) -- (-7,-3)
                (-10,-4) -- (-7,-4);
      \draw [-] (-9,0) -- (-9,-5);
      \node () [anchor=west] at (-10,0.5) {memory};
      \node () [anchor=west] at (-10,-2.5)  {\texttt{\color{blue}x}};
      \node () [anchor=west] at (-9,-2.5) {\texttt{\color{blue}0}};

      \node () [anchor=west] at (-10,-3.5)  {\texttt{\color{blue}y}};
      \node () [anchor=west] at (-9,-3.5)  {\texttt{\color{blue}0}};

      \node () [anchor=center] at (-2,-3.5) {store buffer of t. 0};
      \node () [anchor=center] at (4,-3.5) {store buffer of t. 1};

      \draw [-] (-4,-4) rectangle (0,-5);
      \draw [-] (2,-4) rectangle (6,-5);
      \draw [-] (-2,-4) -- (-2,-5);
      \draw [-] (4,-4) -- (4,-5);

      \node () [anchor=west] at (-4,-4.5)  {\texttt{\color{red}y}};
      \node () [anchor=west] at (-2,-4.5)  {\texttt{\color{red}1}};

      \node () [anchor=west] at (2,-4.5)  {\texttt{\color{red}x}};
      \node () [anchor=west] at (4,-4.5)  {\texttt{\color{red}1}};

      \node () [] at (-4, 0.5) {thread 0};
      \draw [->, thck] (-4,0) -- (-4,-3);
      \node () [anchor=west] at (-3.5, -0.5) {\texttt{\color{red}y = 1;}};
      \node () [anchor=west] at (-3.5, -1.5) {\texttt{\color{blue}load x; \textrightarrow 0}};
      \node () [anchor=west] at (-3.5, -2.5) {\texttt{\color{dgreen}load y; \textrightarrow 1}};

      \node () [] at (2, 0.5) {thread 1};
      \draw [->, thck] (2,0) -- (2,-3);
      \node () [anchor=west] at (2.5, -0.5) {\texttt{\color{red}x = 1;}};
      \node () [anchor=west] at (2.5, -1.5) {\texttt{\color{blue}load y; \textrightarrow 0}};
      \node () [anchor=west] at (2.5, -2.5) {\texttt{\color{dgreen}load x; \textrightarrow 1}};

  \end{tikzpicture}
  \end{center}

  A simple demonstration of the \xtso memory model. The thread 0 writes 1 to
  variable \texttt{y} and then loads variable \texttt{x}, the thread 2 writes 1
  to \texttt{x} and then loads first \texttt{y} and then \texttt{x}.
  Intuitively, we would expect it to be impossible for \texttt{a == 0} and
  \texttt{b == 0} to both hold at the end of the execution.  However, under
  \xtso, the writes are cached in the store buffers (marked as
  \textcolor{red}{red}). A load consults only memory and the store buffer of
  given thread, which means it can ignore newer value from the other thread
  (\textcolor{blue}{blue}). Therefore \texttt{a} and \texttt{b} will contain old
  values from the memory, while \texttt{c} and \texttt{d} will contain local
  values from the store buffers.

\end{block}

\end{column} % End of the double

\begin{column}{\marginwid}\end{column} % Empty spacer column

\end{columns}

\begin{columns}[t]

\begin{column}{\marginwid}\end{column} % Empty spacer column

\begin{column}{\onecolwid}

\begin{block}{Store Buffers}

The typical description of the \xtso memory model is centered around
\emph{store buffers} which are first-in-first-out memories local to each
processor core. Every store the core performs is first saved into the store
buffer. When the core performs load, it consults its store buffers and if the
given address is present in the store buffer it loads it from there, otherwise
it loads it from the main memory. The core never consults store buffers of
other cores. Eventually, each store buffer entry is flushed from the store
buffer to the memory and therefore becomes visible to other threads.

Commonly, the same approach is also used for verification -- stores are
performed into store buffers, which are then nondeterministically flushed to
simulate that the memory hierarchy can take arbitrary time to propagate a store
from the store buffer to the main memory. This nondeterminism is often achieved
by adding a special \emph{flushing thread} which flushes store buffer entries
and can interleave with the other threads freely. The main disadvantage of this
approach is that it can create unnecessary nondeterministic choices and
therefore slow down the verification.

\end{block}

\end{column}

\begin{column}{\sepwid}\end{column} % Empty spacer column


\begin{column}{\onecolwid}

\begin{block}{Our Approach}

The crucial observation behind our approach is that any nondeterministic
decision regarding relaxed behaviour of \xtso can be delayed to the moment in
which loads or fences are executed. This way nondeterminism can be resolved
only when needed and therefore the verification can run faster and with lower
memory footprint.

This does, however, require certain generalization of the store buffers. Store
buffers have to be visible to all threads so that loads can consult other
thread's store buffers and nondeterministically caused them to be flushed if
matching entries are found. Furthermore, to prevent extended nondeterminism when
an entry which is not oldest in the store buffer needs to be flushed, store
buffer entries are extended with a flag which indicates that the corresponding
entry should have been flushed. This allows us to have entries which are in the
store buffer, and therefore their order relative to other buffered entries is
not yet determined, but which have to be flushed once given address is loaded.

Finally, to make the verification decidable, we limit the maximal size of store
buffers. This limit is configurable and defaults to 32 entries in our
implementation.

\end{block}


\end{column} % End of column 2.1

\begin{column}{\sepwid}\end{column} % Empty spacer column
\begin{column}{\onecolwid}

\begin{block}{Results}

We have evaluated our approach on all 54 benchmarks from the SV-COMP's
Concurrency cathegory which do not have data nondeterminism and compared \divine
with CBMC~\cite{Clarke2004} and Nidhugg~\cite{Abdulla2015}. It can be seen that
\divine's solves similar number of benchmarks and finds more bugs.

\begingroup
\bigskip
\centering
\setlength\tabcolsep{0.5em} %
\renewcommand{\arraystretch}{1.1} %
\begin{tabular}{l|ccc}
               & CBMC & DIVINE & Nidhugg \\ \hline
    finished   & 20   & 23     & 24 \\
    TSO errors &  3   & 10     &  3 \\
    unique     &  5   &  6     &  8
\end{tabular}
\endgroup
\end{block}

\begin{block}{References}
\small
\bibliographystyle{plain}
\bibliography{poster}
\end{block}

%----------------------------------------------------------------------------------------

\end{column} % End of column 2.2

\begin{column}{\marginwid}\end{column} % Empty spacer column

\end{columns} % End of all the columns in the poster

\end{frame} % End of the enclosing frame

\end{document}

% vim: spell spelllang=en tw=80 fo+=t
